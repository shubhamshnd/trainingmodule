<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Retro Game Collection</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');

        body {
            font-family: 'Press Start 2P', cursive;
            background-color: black;
            color: white;
            text-align: center;
            overflow-y: hidden;
        }
        
        h1 {
            margin-top: 20px;
        }
        
        .game-container {
            margin: 20px;
        }
        
        button {
            margin: 5px;
            padding: 10px;
            font-size: 16px;
            cursor: pointer;
            background-color: #333;
            color: white;
            border: none;
            border-radius: 5px;
        }
        
        #game-area {
            margin-top: 20px;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 500px;
            border: 1px solid #ccc;
            background-color: #222;
        }
        
        canvas {
            background-color: #000;
        }
        #game2048 {
            display: flex;
            flex-direction: column;
            align-items: center;
            margin-top: 20px;
        }
    
        #board2048 {
            display: grid;
            grid-template-columns: repeat(4, 100px);
            gap: 5px;
        }
    
        .tile {
            width: 100px;
            height: 100px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 24px;
            font-weight: bold;
            border-radius: 5px;
        }
    
        #score2048 {
            margin-top: 10px;
            font-size: 24px;
        }
    </style>
</head>
<body>
    <h1>Retro Game Collection</h1>
    <div class="game-container">
        <button onclick="showGame('spaceShooter')">Space Shooter</button>
        <button onclick="showGame('snake')">Snake</button>
        <button onclick="showGame('ticTacToe')">Tic Tac Toe</button>
        <button onclick="showGame('flappyBird')">Flappy Bird</button>
        <button onclick="showGame('brickBreaker')">Brick Breaker</button>
        <button onclick="showGame('tetris')">Tetris</button>
        <button onclick="showGame('2048')">2048</button>
        <button onclick="showGame('PacMan')">PacMan</button>
    </div>
    <div id="game-area">
        <!-- Game will be loaded here -->
    </div>
    <script>


        function showGame(game) {
            let gameArea = document.getElementById('game-area');
            gameArea.innerHTML = '<button id="playButton">Play</button>'; // Add play button
        
            const playButton = document.getElementById('playButton');
            playButton.onclick = () => {
                playButton.style.display = 'none'; // Hide play button
                if (game === 'spaceShooter') {
                    loadSpaceShooter(gameArea);
                } else if (game === 'snake') {
                    loadSnake(gameArea);
                } else if (game === 'ticTacToe') {
                    loadTicTacToe(gameArea);
                } else if (game === 'flappyBird') {
                    loadFlappyBird(gameArea);
                } else if (game === 'brickBreaker') {
                    loadBrickBreaker(gameArea);
                } else if (game === 'tetris') {
                    loadTetris(gameArea);
                } else if (game === '2048') {
                    load2048(gameArea);
                } else if (game === 'pacMan') {
                    loadPacMan(gameArea);
                }
            };
        }
        function loadPacMan(container) {
            container.innerHTML = '<canvas id="pacManCanvas" width="400" height="400"></canvas>';
            const canvas = document.getElementById('pacManCanvas');
            const ctx = canvas.getContext('2d');

            const pacMan = {
                x: 50,
                y: 50,
                size: 20,
                speed: 2,
                direction: 'RIGHT'
            };

            const ghosts = [
                { x: 100, y: 100, size: 20, speed: 2, direction: 'LEFT' },
                { x: 150, y: 150, size: 20, speed: 2, direction: 'UP' }
            ];

            const pellets = [];

            for (let i = 0; i < 10; i++) {
                pellets.push({ x: Math.random() * 380, y: Math.random() * 380, size: 5 });
            }

            function drawPacMan() {
                ctx.fillStyle = 'yellow';
                ctx.beginPath();
                ctx.arc(pacMan.x, pacMan.y, pacMan.size, 0.2 * Math.PI, 1.8 * Math.PI);
                ctx.lineTo(pacMan.x, pacMan.y);
                ctx.fill();
            }

            function drawGhosts() {
                ctx.fillStyle = 'red';
                ghosts.forEach(ghost => {
                    ctx.fillRect(ghost.x, ghost.y, ghost.size, ghost.size);
                });
            }

            function drawPellets() {
                ctx.fillStyle = 'white';
                pellets.forEach(pellet => {
                    ctx.beginPath();
                    ctx.arc(pellet.x, pellet.y, pellet.size, 0, 2 * Math.PI);
                    ctx.fill();
                });
            }

            function movePacMan() {
                if (pacMan.direction === 'RIGHT') pacMan.x += pacMan.speed;
                if (pacMan.direction === 'LEFT') pacMan.x -= pacMan.speed;
                if (pacMan.direction === 'UP') pacMan.y -= pacMan.speed;
                if (pacMan.direction === 'DOWN') pacMan.y += pacMan.speed;

                if (pacMan.x > canvas.width) pacMan.x = 0;
                if (pacMan.x < 0) pacMan.x = canvas.width;
                if (pacMan.y > canvas.height) pacMan.y = 0;
                if (pacMan.y < 0) pacMan.y = canvas.height;
            }

            function moveGhosts() {
                ghosts.forEach(ghost => {
                    if (ghost.direction === 'RIGHT') ghost.x += ghost.speed;
                    if (ghost.direction === 'LEFT') ghost.x -= ghost.speed;
                    if (ghost.direction === 'UP') ghost.y -= ghost.speed;
                    if (ghost.direction === 'DOWN') ghost.y += ghost.speed;

                    if (ghost.x > canvas.width) ghost.x = 0;
                    if (ghost.x < 0) ghost.x = canvas.width;
                    if (ghost.y > canvas.height) ghost.y = 0;
                    if (ghost.y < 0) ghost.y = canvas.height;

                    if (Math.random() < 0.01) {
                        const directions = ['RIGHT', 'LEFT', 'UP', 'DOWN'];
                        ghost.direction = directions[Math.floor(Math.random() * directions.length)];
                    }
                });
            }

            function checkCollisions() {
                ghosts.forEach(ghost => {
                    if (Math.abs(ghost.x - pacMan.x) < pacMan.size && Math.abs(ghost.y - pacMan.y) < pacMan.size) {
                        alert('Game Over');
                        document.location.reload();
                    }
                });

                for (let i = pellets.length - 1; i >= 0; i--) {
                    if (Math.abs(pellets[i].x - pacMan.x) < pacMan.size && Math.abs(pellets[i].y - pacMan.y) < pacMan.size) {
                        pellets.splice(i, 1);
                    }
                }

                if (pellets.length === 0) {
                    alert('You Win!');
                    document.location.reload();
                }
            }

            function update() {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                movePacMan();
                moveGhosts();
                checkCollisions();
                drawPacMan();
                drawGhosts();
                drawPellets();
                requestAnimationFrame(update);
            }

            function keyDown(e) {
                if (e.key === 'ArrowRight') pacMan.direction = 'RIGHT';
                if (e.key === 'ArrowLeft') pacMan.direction = 'LEFT';
                if (e.key === 'ArrowUp') pacMan.direction = 'UP';
                if (e.key === 'ArrowDown') pacMan.direction = 'DOWN';
            }

            document.addEventListener('keydown', keyDown);

            update();
        }
        function load2048(container) {
            container.innerHTML = `
                <div id="game2048">
                    <div id="board2048"></div>
                    <div id="score2048">Score: 0</div>
                </div>
            `;
    
            const boardSize = 4;
            let board = [];
            let score = 0;
    
            function createBoard() {
                for (let r = 0; r < boardSize; r++) {
                    board[r] = [];
                    for (let c = 0; c < boardSize; c++) {
                        board[r][c] = 0;
                    }
                }
                addNewTile();
                addNewTile();
                updateBoard();
            }
    
            function updateBoard() {
                const boardDiv = document.getElementById('board2048');
                boardDiv.innerHTML = '';
                for (let r = 0; r < boardSize; r++) {
                    for (let c = 0; c < boardSize; c++) {
                        let tile = document.createElement('div');
                        tile.className = 'tile';
                        tile.textContent = board[r][c] === 0 ? '' : board[r][c];
                        tile.style.backgroundColor = getTileColor(board[r][c]);
                        boardDiv.appendChild(tile);
                    }
                }
                document.getElementById('score2048').textContent = 'Score: ' + score;
            }
    
            function getTileColor(value) {
                const colors = {
                    0: '#cdc1b4',
                    2: '#eee4da',
                    4: '#ede0c8',
                    8: '#f2b179',
                    16: '#f59563',
                    32: '#f67c5f',
                    64: '#f65e3b',
                    128: '#edcf72',
                    256: '#edcc61',
                    512: '#edc850',
                    1024: '#edc53f',
                    2048: '#edc22e'
                };
                return colors[value] || '#3c3a32';
            }
    
            function addNewTile() {
                let emptyTiles = [];
                for (let r = 0; r < boardSize; r++) {
                    for (let c = 0; c < boardSize; c++) {
                        if (board[r][c] === 0) {
                            emptyTiles.push({ r, c });
                        }
                    }
                }
                if (emptyTiles.length > 0) {
                    let { r, c } = emptyTiles[Math.floor(Math.random() * emptyTiles.length)];
                    board[r][c] = Math.random() < 0.9 ? 2 : 4;
                }
            }
    
            function slideRow(row) {
                row = row.filter(val => val);
                while (row.length < boardSize) {
                    row.push(0);
                }
                return row;
            }
    
            function combineRow(row) {
                for (let i = 0; i < row.length - 1; i++) {
                    if (row[i] === row[i + 1]) {
                        row[i] *= 2;
                        row[i + 1] = 0;
                        score += row[i];
                    }
                }
                return row;
            }
    
            function slide(board) {
                for (let r = 0; r < boardSize; r++) {
                    board[r] = slideRow(board[r]);
                    board[r] = combineRow(board[r]);
                    board[r] = slideRow(board[r]);
                }
                return board;
            }
    
            function rotateBoard(board) {
                let newBoard = [];
                for (let c = 0; c < boardSize; c++) {
                    newBoard[c] = [];
                    for (let r = 0; r < boardSize; r++) {
                        newBoard[c][r] = board[boardSize - 1 - r][c];
                    }
                }
                return newBoard;
            }
    
            function move(direction) {
                if (direction === 'up') {
                    board = rotateBoard(board);
                    board = slide(board);
                    board = rotateBoard(board);
                    board = rotateBoard(board);
                    board = rotateBoard(board);
                } else if (direction === 'down') {
                    board = rotateBoard(board);
                    board = rotateBoard(board);
                    board = rotateBoard(board);
                    board = slide(board);
                    board = rotateBoard(board);
                } else if (direction === 'left') {
                    board = slide(board);
                } else if (direction === 'right') {
                    board = rotateBoard(board);
                    board = rotateBoard(board);
                    board = slide(board);
                    board = rotateBoard(board);
                    board = rotateBoard(board);
                }
                addNewTile();
                updateBoard();
            }
    
            document.addEventListener('keydown', function (e) {
                if (e.key === 'ArrowUp') move('up');
                if (e.key === 'ArrowDown') move('down');
                if (e.key === 'ArrowLeft') move('left');
                if (e.key === 'ArrowRight') move('right');
            });
    
            createBoard();
        }

        function loadSpaceShooter(container) {
            container.innerHTML = '<canvas id="spaceShooterCanvas" width="400" height="400"></canvas>';
            const canvas = document.getElementById('spaceShooterCanvas');
            const ctx = canvas.getContext('2d');
        
            let player = { x: 200, y: 350, width: 20, height: 20, dx: 0 };
            let bullets = [];
            let enemies = [];
            let score = 0;
            let enemyInterval = 2000;
            let lastEnemyTime = 0;
        
            function drawPlayer() {
                ctx.fillStyle = 'white';
                ctx.fillRect(player.x, player.y, player.width, player.height);
            }
        
            function drawBullets() {
                ctx.fillStyle = 'red';
                bullets.forEach(bullet => {
                    ctx.fillRect(bullet.x, bullet.y, bullet.width, bullet.height);
                });
            }
        
            function drawEnemies() {
                ctx.fillStyle = 'green';
                enemies.forEach(enemy => {
                    ctx.fillRect(enemy.x, enemy.y, enemy.width, enemy.height);
                });
            }
        
            function update(time) {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
        
                player.x += player.dx;
        
                bullets.forEach(bullet => {
                    bullet.y -= 4;
                });
        
                enemies.forEach(enemy => {
                    enemy.y += 1;
                });
        
                bullets = bullets.filter(bullet => bullet.y > 0);
                enemies = enemies.filter(enemy => enemy.y < canvas.height);
        
                // Check for collisions
                bullets.forEach((bullet, bulletIndex) => {
                    enemies.forEach((enemy, enemyIndex) => {
                        if (
                            bullet.x < enemy.x + enemy.width &&
                            bullet.x + bullet.width > enemy.x &&
                            bullet.y < enemy.y + enemy.height &&
                            bullet.y + bullet.height > enemy.y
                        ) {
                            bullets.splice(bulletIndex, 1);
                            enemies.splice(enemyIndex, 1);
                            score += 10;
                        }
                    });
                });
        
                // Add new enemies
                if (time - lastEnemyTime > enemyInterval) {
                    enemies.push({ x: Math.random() * (canvas.width - 20), y: 0, width: 20, height: 20 });
                    lastEnemyTime = time;
                }
        
                drawPlayer();
                drawBullets();
                drawEnemies();
        
                ctx.fillStyle = 'white';
                ctx.font = '10px Arial';
                ctx.fillText('Score: ' + score, 10, 10);
        
                requestAnimationFrame(update);
            }
        
            function keyDown(e) {
                if (e.key === 'ArrowRight') player.dx = 2;
                if (e.key === 'ArrowLeft') player.dx = -2;
                if (e.key === ' ') bullets.push({ x: player.x + 10, y: player.y, width: 2, height: 10 });
            }
        
            function keyUp(e) {
                if (e.key === 'ArrowRight' || e.key === 'ArrowLeft') player.dx = 0;
            }
        
            document.addEventListener('keydown', keyDown);
            document.addEventListener('keyup', keyUp);
        
            requestAnimationFrame(update);
        }

        function loadSnake(container) {
            container.innerHTML = '<canvas id="snakeCanvas" width="400" height="400"></canvas>';
            const canvas = document.getElementById('snakeCanvas');
            const ctx = canvas.getContext('2d');
        
            let snake = [{ x: 200, y: 200 }];
            let direction = 'RIGHT';
            let food = { x: Math.floor(Math.random() * 20) * 20, y: Math.floor(Math.random() * 20) * 20 };
            let gameOver = false;
        
            function drawSnake() {
                ctx.fillStyle = 'white';
                snake.forEach(part => {
                    ctx.fillRect(part.x, part.y, 20, 20);
                });
            }
        
            function drawFood() {
                ctx.fillStyle = 'red';
                ctx.fillRect(food.x, food.y, 20, 20);
            }
        
            function update() {
                if (gameOver) return;
        
                ctx.clearRect(0, 0, canvas.width, canvas.height);
        
                let head = { ...snake[0] };
                if (direction === 'RIGHT') head.x += 20;
                if (direction === 'LEFT') head.x -= 20;
                if (direction === 'UP') head.y -= 20;
                if (direction === 'DOWN') head.y += 20;
        
                // Wrap the snake around the canvas
                if (head.x >= canvas.width) head.x = 0;
                if (head.x < 0) head.x = canvas.width - 20;
                if (head.y >= canvas.height) head.y = 0;
                if (head.y < 0) head.y = canvas.height - 20;
        
                snake.unshift(head);
        
                if (head.x === food.x && head.y === food.y) {
                    food = { x: Math.floor(Math.random() * 20) * 20, y: Math.floor(Math.random() * 20) * 20 };
                } else {
                    snake.pop();
                }
        
                if (snake.slice(1).some(part => part.x === head.x && part.y === head.y)) {
                    gameOver = true;
                    setTimeout(() => {
                        alert('Game Over');
                        snake = [{ x: 200, y: 200 }];
                        direction = 'RIGHT';
                        food = { x: Math.floor(Math.random() * 20) * 20, y: Math.floor(Math.random() * 20) * 20 };
                        gameOver = false;
                    }, 100);
                }
        
                drawSnake();
                drawFood();
            }
        
            function gameLoop() {
                update();
                setTimeout(gameLoop, 150);
            }
        
            function keyDown(e) {
                if (e.key === 'ArrowRight' && direction !== 'LEFT') direction = 'RIGHT';
                if (e.key === 'ArrowLeft' && direction !== 'RIGHT') direction = 'LEFT';
                if (e.key === 'ArrowUp' && direction !== 'DOWN') direction = 'UP';
                if (e.key === 'ArrowDown' && direction !== 'UP') direction = 'DOWN';
            }
        
            document.addEventListener('keydown', keyDown);
        
            gameLoop();
        }
        
        function loadTicTacToe(container) {
            container.innerHTML = '<div id="ticTacToeBoard"></div>';
            const board = document.getElementById('ticTacToeBoard');
            board.style.width = '200px';
            board.style.margin = 'auto';
            board.style.display = 'grid';
            board.style.gridTemplateColumns = 'repeat(3, 1fr)';
            board.style.gridGap = '5px';
        
            let cells = [];
            let currentPlayer = 'X';
        
            for (let i = 0; i < 9; i++) {
                let cell = document.createElement('div');
                cell.style.width = '60px';
                cell.style.height = '60px';
                cell.style.border = '1px solid white';
                cell.style.fontSize = '40px';
                cell.style.display = 'flex';
                cell.style.alignItems = 'center';
                cell.style.justifyContent = 'center';
                cell.style.cursor = 'pointer';
                cell.addEventListener('click', () => makeMove(cell, i));
                cells.push(cell);
                board.appendChild(cell);
            }
        
            function makeMove(cell, index) {
                if (!cell.textContent) {
                    cell.textContent = currentPlayer;
                    if (checkWin()) {
                        setTimeout(() => alert(`${currentPlayer} wins!`), 10);
                        resetBoard();
                    } else if (cells.every(cell => cell.textContent)) {
                        setTimeout(() => alert(`It's a draw!`), 10);
                        resetBoard();
                    } else {
                        currentPlayer = currentPlayer === 'X' ? 'O' : 'X';
                    }
                }
            }
        
            function checkWin() {
                const winPatterns = [
                    [0, 1, 2], [3, 4, 5], [6, 7, 8], // rows
                    [0, 3, 6], [1, 4, 7], [2, 5, 8], // columns
                    [0, 4, 8], [2, 4, 6] // diagonals
                ];
        
                return winPatterns.some(pattern => 
                    pattern.every(index => cells[index].textContent === currentPlayer)
                );
            }
        
            function resetBoard() {
                cells.forEach(cell => cell.textContent = '');
                currentPlayer = 'X';
            }
        }
        
        function loadFlappyBird(container) {
            container.innerHTML = '<canvas id="flappyBirdCanvas" width="400" height="400"></canvas>';
            const canvas = document.getElementById('flappyBirdCanvas');
            const ctx = canvas.getContext('2d');
        
            let bird = { x: 50, y: 200, width: 20, height: 20, dy: 0 };
            let gravity = 0.5;
            let obstacles = [];
            let isGameOver = false;
            let score = 0;
            let obstacleInterval = 1500;
            let lastObstacleTime = 0;
        
            function drawBird() {
                ctx.fillStyle = 'yellow';
                ctx.fillRect(bird.x, bird.y, bird.width, bird.height);
            }
        
            function drawObstacles() {
                ctx.fillStyle = 'green';
                obstacles.forEach(obstacle => {
                    ctx.fillRect(obstacle.x, obstacle.y, obstacle.width, obstacle.height);
                });
            }
        
            function update(time) {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
        
                bird.dy += gravity;
                bird.y += bird.dy;
        
                if (bird.y + bird.height > canvas.height || bird.y < 0) {
                    isGameOver = true;
                }
        
                obstacles.forEach(obstacle => {
                    obstacle.x -= 2;
                });
        
                obstacles = obstacles.filter(obstacle => obstacle.x + obstacle.width > 0);
        
                obstacles.forEach(obstacle => {
                    if (
                        bird.x < obstacle.x + obstacle.width &&
                        bird.x + bird.width > obstacle.x &&
                        bird.y < obstacle.y + obstacle.height &&
                        bird.y + bird.height > obstacle.y
                    ) {
                        isGameOver = true;
                    }
                });
        
                if (time - lastObstacleTime > obstacleInterval) {
                    const height = Math.random() * (canvas.height - 150) + 50;
                    obstacles.push({ x: canvas.width, y: 0, width: 20, height: height });
                    obstacles.push({ x: canvas.width, y: height + 100, width: 20, height: canvas.height - height - 100 });
                    lastObstacleTime = time;
                    score++;
                }
        
                drawBird();
                drawObstacles();
        
                ctx.fillStyle = 'white';
                ctx.font = '10px Arial';
                ctx.fillText('Score: ' + score, 10, 10);
        
                if (!isGameOver) {
                    requestAnimationFrame(update);
                } else {
                    ctx.fillStyle = 'white';
                    ctx.font = '20px Arial';
                    ctx.fillText('Game Over', 150, 200);
                }
            }
        
            function flap() {
                bird.dy = -8;
            }
        
            document.addEventListener('keydown', (e) => {
                if (e.key === ' ') {
                    flap();
                }
            });
        
            requestAnimationFrame(update);
        }

        function loadBrickBreaker(container) {
            container.innerHTML = '<canvas id="brickBreakerCanvas" width="400" height="400"></canvas>';
            const canvas = document.getElementById('brickBreakerCanvas');
            const ctx = canvas.getContext('2d');
        
            let paddle = { x: 175, y: 380, width: 50, height: 10, dx: 0 };
            let ball = { x: 200, y: 370, width: 10, height: 10, dx: 2, dy: -2 };
            let bricks = [];
            let rows = 5;
            let cols = 7;
            let brickWidth = 50;
            let brickHeight = 20;
            let brickPadding = 10;
            let score = 0;
        
            // Calculate the starting x position to center the bricks
            let offsetX = (canvas.width - (cols * (brickWidth + brickPadding) - brickPadding)) / 2;
        
            for (let r = 0; r < rows; r++) {
                for (let c = 0; c < cols; c++) {
                    bricks.push({ x: offsetX + c * (brickWidth + brickPadding), y: r * (brickHeight + brickPadding) + 30, width: brickWidth, height: brickHeight, destroyed: false });
                }
            }
        
            function drawPaddle() {
                ctx.fillStyle = 'white';
                ctx.fillRect(paddle.x, paddle.y, paddle.width, paddle.height);
            }
        
            function drawBall() {
                ctx.fillStyle = 'red';
                ctx.fillRect(ball.x, ball.y, ball.width, ball.height);
            }
        
            function drawBricks() {
                ctx.fillStyle = 'green';
                bricks.forEach(brick => {
                    if (!brick.destroyed) {
                        ctx.fillRect(brick.x, brick.y, brick.width, brick.height);
                    }
                });
            }
        
            function update() {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
        
                paddle.x += paddle.dx;
                ball.x += ball.dx;
                ball.y += ball.dy;
        
                // Prevent paddle from going outside the canvas
                if (paddle.x < 0) paddle.x = 0;
                if (paddle.x + paddle.width > canvas.width) paddle.x = canvas.width - paddle.width;
        
                if (ball.x + ball.width > canvas.width || ball.x < 0) ball.dx *= -1;
                if (ball.y < 0) ball.dy *= -1;
                if (ball.y + ball.height > canvas.height) {
                    alert('Game Over');
                    document.location.reload();
                }
        
                if (ball.x + ball.width > paddle.x && ball.x < paddle.x + paddle.width && ball.y + ball.height > paddle.y && ball.y < paddle.y + paddle.height) {
                    ball.dy *= -1;
                }
        
                bricks.forEach((brick, index) => {
                    if (!brick.destroyed) {
                        if (ball.x + ball.width > brick.x && ball.x < brick.x + brick.width && ball.y + ball.height > brick.y && ball.y < brick.y + brick.height) {
                            ball.dy *= -1;
                            brick.destroyed = true;
                            score += 10;
                        }
                    }
                });
        
                drawPaddle();
                drawBall();
                drawBricks();
        
                ctx.fillStyle = 'white';
                ctx.font = '10px Arial';
                ctx.fillText('Score: ' + score, 10, 10);
        
                requestAnimationFrame(update);
            }
        
            function keyDown(e) {
                if (e.key === 'ArrowRight') paddle.dx = 4;
                if (e.key === 'ArrowLeft') paddle.dx = -4;
            }
        
            function keyUp(e) {
                if (e.key === 'ArrowRight' || e.key === 'ArrowLeft') paddle.dx = 0;
            }
        
            document.addEventListener('keydown', keyDown);
            document.addEventListener('keyup', keyUp);
        
            requestAnimationFrame(update);
        }
        
        function loadTetris(container) {
            container.innerHTML = '<canvas id="tetrisCanvas" width="200" height="400"></canvas><div id="score" style="color: white; margin-top: 10px;">Score: 0</div>';
            const canvas = document.getElementById('tetrisCanvas');
            const ctx = canvas.getContext('2d');
    
            const ROW = 20;
            const COL = 10;
            const SQ = 20;
            const VACANT = 'black';
    
            function drawSquare(x, y, color) {
                ctx.fillStyle = color;
                ctx.fillRect(x * SQ, y * SQ, SQ, SQ);
    
                ctx.strokeStyle = 'white';
                ctx.strokeRect(x * SQ, y * SQ, SQ, SQ);
            }
    
            let board = [];
            for (r = 0; r < ROW; r++) {
                board[r] = [];
                for (c = 0; c < COL; c++) {
                    board[r][c] = VACANT;
                }
            }
    
            function drawBoard() {
                for (r = 0; r < ROW; r++) {
                    for (c = 0; c < COL; c++) {
                        drawSquare(c, r, board[r][c]);
                    }
                }
            }
    
            drawBoard();
    
            const PIECES = [
                [Z, 'red'],
                [S, 'green'],
                [T, 'yellow'],
                [O, 'blue'],
                [L, 'purple'],
                [I, 'cyan'],
                [J, 'orange']
            ];
    
            function randomPiece() {
                let r = Math.floor(Math.random() * PIECES.length);
                return new Piece(PIECES[r][0], PIECES[r][1]);
            }
    
            function Piece(tetromino, color) {
                this.tetromino = tetromino;
                this.color = color;
                this.tetrominoN = 0;
                this.activeTetromino = this.tetromino[this.tetrominoN];
                this.x = 3;
                this.y = -2;
            }
    
            Piece.prototype.fill = function (color) {
                for (r = 0; r < this.activeTetromino.length; r++) {
                    for (c = 0; c < this.activeTetromino.length; c++) {
                        if (this.activeTetromino[r][c]) {
                            drawSquare(this.x + c, this.y + r, color);
                        }
                    }
                }
            };
    
            Piece.prototype.draw = function () {
                this.fill(this.color);
            };
    
            Piece.prototype.unDraw = function () {
                this.fill(VACANT);
            };
    
            Piece.prototype.moveDown = function () {
                if (!this.collision(0, 1, this.activeTetromino)) {
                    this.unDraw();
                    this.y++;
                    this.draw();
                } else {
                    this.lock();
                    p = randomPiece();
                }
            };
    
            Piece.prototype.moveRight = function () {
                if (!this.collision(1, 0, this.activeTetromino)) {
                    this.unDraw();
                    this.x++;
                    this.draw();
                }
            };
    
            Piece.prototype.moveLeft = function () {
                if (!this.collision(-1, 0, this.activeTetromino)) {
                    this.unDraw();
                    this.x--;
                    this.draw();
                }
            };
    
            Piece.prototype.rotate = function () {
                let nextPattern = this.tetromino[(this.tetrominoN + 1) % this.tetromino.length];
                let kick = 0;
    
                if (this.collision(0, 0, nextPattern)) {
                    if (this.x > COL / 2) {
                        kick = -1;
                    } else {
                        kick = 1;
                    }
                }
    
                if (!this.collision(kick, 0, nextPattern)) {
                    this.unDraw();
                    this.x += kick;
                    this.tetrominoN = (this.tetrominoN + 1) % this.tetromino.length;
                    this.activeTetromino = nextPattern;
                    this.draw();
                }
            };
    
            let score = 0;
    
            Piece.prototype.lock = function () {
                for (r = 0; r < this.activeTetromino.length; r++) {
                    for (c = 0; c < this.activeTetromino.length; c++) {
                        if (!this.activeTetromino[r][c]) {
                            continue;
                        }
                        if (this.y + r < 0) {
                            alert('Game Over');
                            gameOver = true;
                            break;
                        }
                        board[this.y + r][this.x + c] = this.color;
                    }
                }
                for (r = 0; r < ROW; r++) {
                    let isRowFull = true;
                    for (c = 0; c < COL; c++) {
                        isRowFull = isRowFull && (board[r][c] != VACANT);
                    }
                    if (isRowFull) {
                        for (y = r; y > 1; y--) {
                            for (c = 0; c < COL; c++) {
                                board[y][c] = board[y - 1][c];
                            }
                        }
                        for (c = 0; c < COL; c++) {
                            board[0][c] = VACANT;
                        }
                        score += 10;
                        document.getElementById('score').innerHTML = "Score: " + score;
                    }
                }
                drawBoard();
            };
    
            Piece.prototype.collision = function (x, y, piece) {
                for (r = 0; r < piece.length; r++) {
                    for (c = 0; c < piece.length; c++) {
                        if (!piece[r][c]) {
                            continue;
                        }
                        let newX = this.x + c + x;
                        let newY = this.y + r + y;
    
                        if (newX < 0 || newX >= COL || newY >= ROW) {
                            return true;
                        }
                        if (newY < 0) {
                            continue;
                        }
                        if (board[newY][newX] != VACANT) {
                            return true;
                        }
                    }
                }
                return false;
            };
    
            document.addEventListener('keydown', CONTROL);
    
            function CONTROL(event) {
                if (event.keyCode == 37) {
                    p.moveLeft();
                    dropStart = Date.now();
                } else if (event.keyCode == 38) {
                    p.rotate();
                    dropStart = Date.now();
                } else if (event.keyCode == 39) {
                    p.moveRight();
                    dropStart = Date.now();
                } else if (event.keyCode == 40) {
                    p.moveDown();
                }
            }
    
            let dropStart = Date.now();
            let gameOver = false;
            function drop() {
                let now = Date.now();
                let delta = now - dropStart;
                if (delta > 1000) {
                    p.moveDown();
                    dropStart = Date.now();
                }
                if (!gameOver) {
                    requestAnimationFrame(drop);
                }
            }
    
            let p = randomPiece();
            drop();
        }
    
        const I = [
            [
                [0, 0, 0, 0],
                [1, 1, 1, 1],
                [0, 0, 0, 0],
                [0, 0, 0, 0]
            ],
            [
                [0, 0, 1, 0],
                [0, 0, 1, 0],
                [0, 0, 1, 0],
                [0, 0, 1, 0]
            ],
            [
                [0, 0, 0, 0],
                [1, 1, 1, 1],
                [0, 0, 0, 0],
                [0, 0, 0, 0]
            ],
            [
                [0, 0, 1, 0],
                [0, 0, 1, 0],
                [0, 0, 1, 0],
                [0, 0, 1, 0]
            ]
        ];
    
        const J = [
            [
                [1, 0, 0],
                [1, 1, 1],
                [0, 0, 0]
            ],
            [
                [0, 1, 1],
                [0, 1, 0],
                [0, 1, 0]
            ],
            [
                [0, 0, 0],
                [1, 1, 1],
                [0, 0, 1]
            ],
            [
                [0, 1, 0],
                [0, 1, 0],
                [1, 1, 0]
            ]
        ];
    
        const L = [
            [
                [0, 0, 1],
                [1, 1, 1],
                [0, 0, 0]
            ],
            [
                [0, 1, 0],
                [0, 1, 0],
                [0, 1, 1]
            ],
            [
                [0, 0, 0],
                [1, 1, 1],
                [1, 0, 0]
            ],
            [
                [1, 1, 0],
                [0, 1, 0],
                [0, 1, 0]
            ]
        ];
    
        const O = [
            [
                [1, 1],
                [1, 1]
            ]
        ];
    
        const S = [
            [
                [0, 1, 1],
                [1, 1, 0],
                [0, 0, 0]
            ],
            [
                [0, 1, 0],
                [0, 1, 1],
                [0, 0, 1]
            ],
            [
                [0, 0, 0],
                [0, 1, 1],
                [1, 1, 0]
            ],
            [
                [1, 0, 0],
                [1, 1, 0],
                [0, 1, 0]
            ]
        ];
    
        const T = [
            [
                [0, 1, 0],
                [1, 1, 1],
                [0, 0, 0]
            ],
            [
                [0, 1, 0],
                [0, 1, 1],
                [0, 1, 0]
            ],
            [
                [0, 0, 0],
                [1, 1, 1],
                [0, 1, 0]
            ],
            [
                [0, 1, 0],
                [1, 1, 0],
                [0, 1, 0]
            ]
        ];
    
        const Z = [
            [
                [1, 1, 0],
                [0, 1, 1],
                [0, 0, 0]
            ],
            [
                [0, 0, 1],
                [0, 1, 1],
                [0, 1, 0]
            ],
            [
                [0, 0, 0],
                [1, 1, 0],
                [0, 1, 1]
            ],
            [
                [0, 1, 0],
                [1, 1, 0],
                [1, 0, 0]
            ]
        ];
    </script>
</body>
</html>
